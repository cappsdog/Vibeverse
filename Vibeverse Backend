# File: README.md

# VibeverseBackend 

Express API wrapped with `serverless-http` to run on **Vercel functions**.

> ⚠️ Notes / Constraints on Vercel:
> - **No local disk for uploads** → use S3/Cloudinary (this build disables file storage).
> - **No WebSockets** → use polling or 3rd‑party Pusher/Ably (not included).
> - **Cold starts** possible. Keep functions small.
> - Use **MongoDB Atlas** for the database.

If you need full Express with file uploads & sockets, deploy to **Render/Railway/Fly** instead; frontend can still be on Vercel.

## Quick Start (local)
```bash
npm i
cp .env.example .env
# set: MONGODB_URI, JWT_SECRET, PAYPAL_CLIENT_ID, PAYPAL_CLIENT_SECRET, FRONTEND_URL
npm run dev
```

## Deploy to Vercel
1. Push this folder to **GitHub**.
2. Vercel → New Project → Import Git repo.
3. Set env vars (see `.env.example`).
4. Deploy.

---

# File: package.json
{
  "name": "vibeverse-backend",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vercel dev",
    "start": "node api/index.js"
  },
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.5.2",
    "node-fetch": "^3.3.2",
    "serverless-http": "^3.2.0",
    "uuid": "^9.0.1"
  },
  "devDependencies": {
    "vercel": "^39.1.0"
  }
}

---

# File: vercel.json
{
  "functions": {
    "api/index.js": {
      "memory": 512,
      "maxDuration": 10
    }
  },
  "routes": [
    { "src": "/api/(.*)", "dest": "/api/index.js" }
  ]
}

---

# File: .env.example
MONGODB_URI=mongodb+srv://USER:PASS@cluster0.xxxxx.mongodb.net/vibeverse
JWT_SECRET=change_this
PAYPAL_CLIENT_ID=your_paypal_live_client_id
PAYPAL_CLIENT_SECRET=your_paypal_live_secret
FRONTEND_URL=https://vibeverse.vip
NODE_ENV=production

---

# File: src/db.js
import mongoose from 'mongoose'

let isConnected = false
export async function connectDB(uri) {
  if (isConnected) return
  mongoose.set('strictQuery', true)
  await mongoose.connect(uri, { dbName: 'vibeverse' })
  isConnected = true
}

---

# File: src/models/User.js
import { Schema, model, models } from 'mongoose'

const UserSchema = new Schema({
  username: { type: String, unique: true, required: true },
  email: { type: String, unique: true, required: true },
  password: { type: String, required: true },
  avatar: { type: String },
  bio: { type: String },
  plan: { type: String, enum: ['free', 'plus', 'pro'], default: 'free' },
  planExpiresAt: { type: Date, default: null },
  createdAt: { type: Date, default: Date.now }
})

export default models.User || model('User', UserSchema)

---

# File: src/models/Comment.js
import { Schema, model, models } from 'mongoose'

const CommentSchema = new Schema({
  author: { type: Schema.Types.ObjectId, ref: 'User', required: true },
  post: { type: Schema.Types.ObjectId, ref: 'VibePost', required: true },
  content: { type: String, required: true },
  createdAt: { type: Date, default: Date.now }
})

export default models.Comment || model('Comment', CommentSchema)

---

# File: src/models/VibePost.js
import { Schema, model, models } from 'mongoose'

const VibePostSchema = new Schema({
  author: { type: Schema.Types.ObjectId, ref: 'User', required: true },
  content: { type: String, required: true },
  image: { type: String },
  mood: { type: String },
  likes: [{ type: Schema.Types.ObjectId, ref: 'User' }],
  comments: [{ type: Schema.Types.ObjectId, ref: 'Comment' }],
  createdAt: { type: Date, default: Date.now }
})

export default models.VibePost || model('VibePost', VibePostSchema)

---

# File: src/middleware/auth.js
import jwt from 'jsonwebtoken'
import User from '../models/User.js'

export async function auth(req, res, next) {
  const token = req.headers.authorization?.replace('Bearer ', '')
  if (!token) return res.status(401).json({ error: 'No token' })
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET)
    req.user = await User.findById(decoded.id).select('-password')
    if (!req.user) return res.status(401).json({ error: 'Invalid user' })
    next()
  } catch (e) { return res.status(401).json({ error: 'Invalid token' }) }
}

---

# File: src/routes/auth.js
import { Router } from 'express'
import bcrypt from 'bcryptjs'
import jwt from 'jsonwebtoken'
import User from '../models/User.js'

const router = Router()

router.post('/register', async (req, res) => {
  const { username, email, password } = req.body
  if (!username || !email || !password) return res.status(400).json({ error: 'Missing fields' })
  try {
    const exists = await User.findOne({ $or: [{ email }, { username }] })
    if (exists) return res.status(400).json({ error: 'User exists' })
    const hashed = await bcrypt.hash(password, 10)
    const user = await User.create({ username, email, password: hashed })
    const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET, { expiresIn: '7d' })
    res.json({ token, user: { id: user._id, username, email, plan: user.plan } })
  } catch (e) { res.status(500).json({ error: 'Server error' }) }
})

router.post('/login', async (req, res) => {
  const { email, password } = req.body
  try {
    const user = await User.findOne({ email })
    if (!user) return res.status(400).json({ error: 'Invalid credentials' })
    const ok = await bcrypt.compare(password, user.password)
    if (!ok) return res.status(400).json({ error: 'Invalid credentials' })
    const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET, { expiresIn: '7d' })
    res.json({ token, user: { id: user._id, username: user.username, email, plan: user.plan } })
  } catch (e) { res.status(500).json({ error: 'Server error' }) }
})

export default router

---

# File: src/routes/vibes.js
import { Router } from 'express'
import { auth } from '../middleware/auth.js'
import VibePost from '../models/VibePost.js'

const router = Router()

router.get('/', async (_req, res) => {
  const items = await VibePost.find().sort({ createdAt: -1 }).limit(50).populate('author', 'username')
  res.json(items)
})

router.post('/', auth, async (req, res) => {
  const { content, mood, image } = req.body
  if (!content) return res.status(400).json({ error: 'Content required' })
  const post = await VibePost.create({ author: req.user._id, content, mood, image })
  res.status(201).json(post)
})

router.post('/:id/like', auth, async (req, res) => {
  const post = await VibePost.findById(req.params.id)
  if (!post) return res.status(404).json({ error: 'Not found' })
  const has = post.likes.some(u => u.equals(req.user._id))
  if (!has) post.likes.push(req.user._id)
  await post.save()
  res.json({ likes: post.likes.length })
})

export default router

---

# File: src/routes/plans.js
import { Router } from 'express'
import fetch from 'node-fetch'
import { v4 as uuidv4 } from 'uuid'
import { auth } from '../middleware/auth.js'
import User from '../models/User.js'

const router = Router()

const PLANS = [
  { id: 'free', name: 'Free', price: 0, currency: 'GBP' },
  { id: 'plus', name: 'Vibe Plus', price: 7.99, currency: 'GBP' },
  { id: 'pro', name: 'Creator Pro', price: 19.99, currency: 'GBP' }
]

const PAYPAL_API = 'https://api-m.paypal.com'

async function getToken() {
  const res = await fetch(`${PAYPAL_API}/v1/oauth2/token`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
      'Authorization': 'Basic ' + Buffer.from(`${process.env.PAYPAL_CLIENT_ID}:${process.env.PAYPAL_CLIENT_SECRET}`).toString('base64')
    },
    body: 'grant_type=client_credentials'
  })
  const json = await res.json()
  return json.access_token
}

router.get('/', (_req, res) => res.json(PLANS))

router.post('/subscribe', auth, async (req, res) => {
  const { planId } = req.body
  const plan = PLANS.find(p => p.id === planId && p.price > 0)
  if (!plan) return res.status(400).json({ error: 'Invalid plan' })
  const token = await getToken()
  const r = await fetch(`${PAYPAL_API}/v2/checkout/orders`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` },
    body: JSON.stringify({
      intent: 'CAPTURE',
      purchase_units: [{
        reference_id: uuidv4(),
        description: plan.name,
        amount: { currency_code: plan.currency, value: plan.price.toFixed(2) }
      }],
      application_context: {
        return_url: `${process.env.FRONTEND_URL}/pricing/success?plan=${planId}`,
        cancel_url: `${process.env.FRONTEND_URL}/pricing/cancel?plan=${planId}`,
        brand_name: 'Vibeverse'
      }
    })
  })
  const data = await r.json()
  const approval = data.links?.find(l => l.rel === 'approve')?.href
  if (!approval) return res.status(500).json({ error: 'PayPal order failed' })
  res.json({ approvalUrl: approval })
})

router.post('/capture', auth, async (req, res) => {
  const { orderId, planId } = req.body
  const token = await getToken()
  const r = await fetch(`${PAYPAL_API}/v2/checkout/orders/${orderId}/capture`, {
    method: 'POST', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` }
  })
  const data = await r.json()
  if (data.status === 'COMPLETED') {
    const user = await User.findByIdAndUpdate(req.user._id, { plan: planId }, { new: true })
    return res.json({ success: true, plan: user.plan })
  }
  res.status(400).json({ error: 'Payment not completed' })
})

export default router

---

# File: src/app.js
import express from 'express'
import cors from 'cors'
import authRoutes from './routes/auth.js'
import vibeRoutes from './routes/vibes.js'
import planRoutes from './routes/plans.js'

const app = express()
app.use(cors({ origin: process.env.FRONTEND_URL, credentials: true }))
app.use(express.json())

app.get('/api/health', (_req, res) => res.json({ ok: true }))
app.use('/api/auth', authRoutes)
app.use('/api/vibes', vibeRoutes)
app.use('/api/plans', planRoutes)

export default app

---

# File: api/index.js
import serverless from 'serverless-http'
import app from '../src/app.js'
import { connectDB } from '../src/db.js'

let handler

export default async function(req, res) {
  if (!handler) {
    await connectDB(process.env.MONGODB_URI)
    handler = serverless(app)
  }
  return handler(req, res)
}

